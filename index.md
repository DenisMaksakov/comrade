---
layout: default
curlang: ru
title: Home page
addcss: badges
---

## Концепции и принципы ООП
Язык **Python** – типичный представитель ООП-семейства, обладающий элегантной и мощной объектной моделью. В этом языке от объектов никуда не спрятаться (ведь даже числа являются ими), поэтому давайте разбираться, как это все реализовано.

**Объектно-ориентированная парадигма** имеет несколько принципов:
* Данные структурируются в виде объектов, каждый из которых имеет определенный тип, то есть принадлежит к какому-либо классу.
* Классы – результат формализации решаемой задачи, выделения главных ее аспектов.
* Внутри объекта инкапсулируется логика работы с относящейся к нему информацией.
* Объекты в программе взаимодействуют друг с другом, обмениваются запросами и ответами.
* При этом объекты одного типа сходным образом отвечают на одни и те же запросы.
* Объекты могут организовываться в более сложные структуры, например, включать другие объекты или наследовать от одного или нескольких объектов.


## Классы, объекты, экземпляры классов
### Объект
Ключевым понятием ООП является понятие *«Объект»*. И **Python** этим понятием активно пользуется на всех уровнях, потому что любое значение, с которым вы работаете когда программируете на **Python**, является объектом. Так что же такое *«Объект»*?

С точки зрения ООП *«Объект»* - это контейнер состоящий из:
1. данных, обозначающих текущее состояния объекта
2. поведения

### Класс
Следующим ключевым понятие ООП является понятие *«Класс»*.
Класс объекта - это коллекция характеристик объединяющая атрибуты имеющиеся у всех экземпляров(объектов) подобного класса.
Функция `isinstance()` в **Python**, позволяет проверить принадлежность экземпляра к классу. 
```python
a = 5  
type(a)  # <class 'int'>  
isinstance(a, int)  # True  
isinstance(int, type)  # True  
isinstance(type, object)  # True  
isinstance(a, object)  # True
```
Начиная с 3-й версии в языке программирования **Python** все классы неявно имеют один общий суперкласс - `object` и все классы по умолчанию наследуют его методы.

#### Создание своего класса
Объекты принадлежат классам и создаются на основании классов. Для создания ключевое слово `class` и через пробел нужно указать имя класса:
```python
class Person:
    pass
```

> По стандарту [PEP 8](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html) имя класса обязательно пишется с большой буквы, если имя содержит несколько слов необходимо оформлять по типу написания **CamelCase**.

#### Атрибуты класса
Подобные атрибуты определяются в виде переменных уровня класса и являются общими для всех объектов класса. Могут применяться для ситуаций, когда нам надо определить некоторые общие данные для всех объектов:
```python
class Person:  
    unit = 'Human'  
    planet = 'Earth'
```
> Для получения всех атрибутов содержащихся в классе или в экземпляре класса применяется магический атрибут `__dict__`.

```python
Person.__dict__
mappingproxy({..., 'unit': 'Human', 'planet': 'Earth', ...})
```
#### Обращение к атрибутам класса
Обратиться к атрибутам класса можно через `class.attribute` или с помощью функции `getattr`:
```python
Person.unit  # Human  
getattr(Person, 'planet')  # Earth
```

> Обычно **getattr**(*obj*, *name[, default]*) используется в тех случаях, когда объект и/или имя атрибута может варьироваться (является переменной).
>||||
>|-|-|-|
>| *obj* | `object` |Объект, значение атрибута которого требуется получить.|
>|*name*|`str`|Имя атрибута, значение которого требуется получить.|
>|*default*|`...`|Значение по умолчанию, которое будет возвращено, если объект не располагает указанным атрибутом. Если не задано, и атрибут отсутствует, возбуждается исключение `AttributeError`.|

#### Изменение атрибута класса
```python
Person.unit = 'elephant'  
getattr(Person, 'unit')  # elephant
```
#### Создание атрибута класса
Новый атрибут создается функцией `setattr` или при помощи присвоения значения атрибуту, в случае его отсутствия в классе:
```python
Person.age = 33
setattr(Person, 'color', 'white')
Person.__dict__  # ..., 'age': 33, 'color': 'white', ...
```
>Метод **setattr**(*obj*, *name*, *value*) зачастую используется в случаях, когда имя атрибута и/или значение заранее неизвестно и содержится в переменной.
>||||
>|-|-|-|
>|*obj*|`object`|Объект, который следует дополнить атрибутом.|
>|*name*|`str`|Строка с именем атрибута. Можно указывать как имя нового, так и существующего атрибута.
>|*value*|`...`|Произвольное значение атрибута.

#### Удаление атрибутов класса
Для удаления атрибута следует применять оператор `del` или функцию `delattr`:
```python
del Person.age
delattr(Person, 'color')
```
#### Функции как атрибут класса
Кроме атрибутов в виде переменных класса, в качестве атрибутов класса также применяются функции.
```python
class Person:  
    unit = 'Human'  
    planet = 'Earth'  
  
    def hello():  
        print(f'Hello!')  

  
Person.hello()  # Hello!  
getattr(Person, 'hello')()  # Hello!
```
>Обратиться напрямую к атрибуту-функции(методу) класса через экземпляр класса невозможно, возникнет ошибка отсутствия обязательного аргумента.

### Экземпляр класса
**Экземпляр класса** (*англ.* instance) — это описание конкретного объекта в памяти. **Класс** описывает свойства и методы, которые будут доступны у объекта, построенного по описанию, заложенному в классе. **Экземпляры** используются для представления (моделирования) конкретных сущностей реального мира.

Все операции, которые применимы в отношении базового класса имеют такое же применение и по отношению к экземплярам классов (далее ЭК).
```python
class Person:  
    unit = 'Human'  
    planet = 'Earth'  
  
  
denis = Person()  
  
denis.age = 33  
print(denis.__dict__)  # {'age': 33}  
del denis.age  
print(denis.__dict__)  # {}
```
>Помните, что атрибуты класса относятся только к самому классу и при создании ЭК эти атрибуты не создаются в самом ЭК, а получают ссылку на атрибут класса. Но в случае изменения атрибута из под ЭК, данный атрибут со своим значением отразится в словаре атрибутов.
